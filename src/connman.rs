// This code was autogenerated with `dbus-codegen-rust -s -g -m None -d net.connman --interfaces net.connman.Manager -p /`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::blocking;

pub trait NetConnmanManager {
    fn get_properties(&self) -> Result<arg::PropMap, dbus::Error>;
    fn set_property<I1: arg::Arg + arg::Append>(
        &self,
        name: &str,
        value: I1,
    ) -> Result<(), dbus::Error>;
    fn get_technologies(&self) -> Result<Vec<(dbus::Path<'static>, arg::PropMap)>, dbus::Error>;
    fn remove_provider(&self, provider: dbus::Path) -> Result<(), dbus::Error>;
    fn get_services(&self) -> Result<Vec<(dbus::Path<'static>, arg::PropMap)>, dbus::Error>;
    fn get_peers(&self) -> Result<Vec<(dbus::Path<'static>, arg::PropMap)>, dbus::Error>;
    fn get_tethering_clients(&self) -> Result<Vec<String>, dbus::Error>;
    fn connect_provider(&self, provider: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn register_agent(&self, path: dbus::Path) -> Result<(), dbus::Error>;
    fn unregister_agent(&self, path: dbus::Path) -> Result<(), dbus::Error>;
    fn register_counter(
        &self,
        path: dbus::Path,
        accuracy: u32,
        period: u32,
    ) -> Result<(), dbus::Error>;
    fn unregister_counter(&self, path: dbus::Path) -> Result<(), dbus::Error>;
    fn create_session(
        &self,
        settings: arg::PropMap,
        notifier: dbus::Path,
    ) -> Result<dbus::Path<'static>, dbus::Error>;
    fn destroy_session(&self, session: dbus::Path) -> Result<(), dbus::Error>;
    fn request_private_network(
        &self,
    ) -> Result<(dbus::Path<'static>, arg::PropMap, arg::OwnedFd), dbus::Error>;
    fn release_private_network(&self, path: dbus::Path) -> Result<(), dbus::Error>;
    fn register_peer_service(
        &self,
        specification: arg::PropMap,
        master: bool,
    ) -> Result<(), dbus::Error>;
    fn unregister_peer_service(&self, specification: arg::PropMap) -> Result<(), dbus::Error>;
}

#[derive(Debug)]
pub struct NetConnmanManagerPropertyChanged {
    pub name: String,
    pub value: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl arg::AppendAll for NetConnmanManagerPropertyChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.name, i);
        arg::RefArg::append(&self.value, i);
    }
}

impl arg::ReadAll for NetConnmanManagerPropertyChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(NetConnmanManagerPropertyChanged {
            name: i.read()?,
            value: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for NetConnmanManagerPropertyChanged {
    const NAME: &'static str = "PropertyChanged";
    const INTERFACE: &'static str = "net.connman.Manager";
}

#[derive(Debug)]
pub struct NetConnmanManagerTechnologyAdded {
    pub path: dbus::Path<'static>,
    pub properties: arg::PropMap,
}

impl arg::AppendAll for NetConnmanManagerTechnologyAdded {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.path, i);
        arg::RefArg::append(&self.properties, i);
    }
}

impl arg::ReadAll for NetConnmanManagerTechnologyAdded {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(NetConnmanManagerTechnologyAdded {
            path: i.read()?,
            properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for NetConnmanManagerTechnologyAdded {
    const NAME: &'static str = "TechnologyAdded";
    const INTERFACE: &'static str = "net.connman.Manager";
}

#[derive(Debug)]
pub struct NetConnmanManagerTechnologyRemoved {
    pub path: dbus::Path<'static>,
}

impl arg::AppendAll for NetConnmanManagerTechnologyRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.path, i);
    }
}

impl arg::ReadAll for NetConnmanManagerTechnologyRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(NetConnmanManagerTechnologyRemoved { path: i.read()? })
    }
}

impl dbus::message::SignalArgs for NetConnmanManagerTechnologyRemoved {
    const NAME: &'static str = "TechnologyRemoved";
    const INTERFACE: &'static str = "net.connman.Manager";
}

#[derive(Debug)]
pub struct NetConnmanManagerServicesChanged {
    pub changed: Vec<(dbus::Path<'static>, arg::PropMap)>,
    pub removed: Vec<dbus::Path<'static>>,
}

impl arg::AppendAll for NetConnmanManagerServicesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.changed, i);
        arg::RefArg::append(&self.removed, i);
    }
}

impl arg::ReadAll for NetConnmanManagerServicesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(NetConnmanManagerServicesChanged {
            changed: i.read()?,
            removed: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for NetConnmanManagerServicesChanged {
    const NAME: &'static str = "ServicesChanged";
    const INTERFACE: &'static str = "net.connman.Manager";
}

#[derive(Debug)]
pub struct NetConnmanManagerPeersChanged {
    pub changed: Vec<(dbus::Path<'static>, arg::PropMap)>,
    pub removed: Vec<dbus::Path<'static>>,
}

impl arg::AppendAll for NetConnmanManagerPeersChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.changed, i);
        arg::RefArg::append(&self.removed, i);
    }
}

impl arg::ReadAll for NetConnmanManagerPeersChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(NetConnmanManagerPeersChanged {
            changed: i.read()?,
            removed: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for NetConnmanManagerPeersChanged {
    const NAME: &'static str = "PeersChanged";
    const INTERFACE: &'static str = "net.connman.Manager";
}

#[derive(Debug)]
pub struct NetConnmanManagerTetheringClientsChanged {
    pub registered: Vec<String>,
    pub removed: Vec<String>,
}

impl arg::AppendAll for NetConnmanManagerTetheringClientsChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.registered, i);
        arg::RefArg::append(&self.removed, i);
    }
}

impl arg::ReadAll for NetConnmanManagerTetheringClientsChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(NetConnmanManagerTetheringClientsChanged {
            registered: i.read()?,
            removed: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for NetConnmanManagerTetheringClientsChanged {
    const NAME: &'static str = "TetheringClientsChanged";
    const INTERFACE: &'static str = "net.connman.Manager";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target = T>> NetConnmanManager
    for blocking::Proxy<'a, C>
{
    fn get_properties(&self) -> Result<arg::PropMap, dbus::Error> {
        self.method_call("net.connman.Manager", "GetProperties", ())
            .and_then(|r: (arg::PropMap,)| Ok(r.0))
    }

    fn set_property<I1: arg::Arg + arg::Append>(
        &self,
        name: &str,
        value: I1,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "net.connman.Manager",
            "SetProperty",
            (name, arg::Variant(value)),
        )
    }

    fn get_technologies(&self) -> Result<Vec<(dbus::Path<'static>, arg::PropMap)>, dbus::Error> {
        self.method_call("net.connman.Manager", "GetTechnologies", ())
            .and_then(|r: (Vec<(dbus::Path<'static>, arg::PropMap)>,)| Ok(r.0))
    }

    fn remove_provider(&self, provider: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("net.connman.Manager", "RemoveProvider", (provider,))
    }

    fn get_services(&self) -> Result<Vec<(dbus::Path<'static>, arg::PropMap)>, dbus::Error> {
        self.method_call("net.connman.Manager", "GetServices", ())
            .and_then(|r: (Vec<(dbus::Path<'static>, arg::PropMap)>,)| Ok(r.0))
    }

    fn get_peers(&self) -> Result<Vec<(dbus::Path<'static>, arg::PropMap)>, dbus::Error> {
        self.method_call("net.connman.Manager", "GetPeers", ())
            .and_then(|r: (Vec<(dbus::Path<'static>, arg::PropMap)>,)| Ok(r.0))
    }

    fn get_tethering_clients(&self) -> Result<Vec<String>, dbus::Error> {
        self.method_call("net.connman.Manager", "GetTetheringClients", ())
            .and_then(|r: (Vec<String>,)| Ok(r.0))
    }

    fn connect_provider(&self, provider: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("net.connman.Manager", "ConnectProvider", (provider,))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn register_agent(&self, path: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("net.connman.Manager", "RegisterAgent", (path,))
    }

    fn unregister_agent(&self, path: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("net.connman.Manager", "UnregisterAgent", (path,))
    }

    fn register_counter(
        &self,
        path: dbus::Path,
        accuracy: u32,
        period: u32,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "net.connman.Manager",
            "RegisterCounter",
            (path, accuracy, period),
        )
    }

    fn unregister_counter(&self, path: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("net.connman.Manager", "UnregisterCounter", (path,))
    }

    fn create_session(
        &self,
        settings: arg::PropMap,
        notifier: dbus::Path,
    ) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("net.connman.Manager", "CreateSession", (settings, notifier))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn destroy_session(&self, session: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("net.connman.Manager", "DestroySession", (session,))
    }

    fn request_private_network(
        &self,
    ) -> Result<(dbus::Path<'static>, arg::PropMap, arg::OwnedFd), dbus::Error> {
        self.method_call("net.connman.Manager", "RequestPrivateNetwork", ())
    }

    fn release_private_network(&self, path: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("net.connman.Manager", "ReleasePrivateNetwork", (path,))
    }

    fn register_peer_service(
        &self,
        specification: arg::PropMap,
        master: bool,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "net.connman.Manager",
            "RegisterPeerService",
            (specification, master),
        )
    }

    fn unregister_peer_service(&self, specification: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call(
            "net.connman.Manager",
            "UnregisterPeerService",
            (specification,),
        )
    }
}
